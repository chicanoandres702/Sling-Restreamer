<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unified TCP Streamer</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: #0a0a0f; color: #e8eaed; min-height: 100vh; }
        .container { max-width: 1400px; margin: 0 auto; padding: 2rem; }
        header { text-align: center; margin-bottom: 3rem; padding: 2rem; background: rgba(20, 20, 28, 0.6); backdrop-filter: blur(20px); border-radius: 24px; border: 1px solid rgba(255, 255, 255, 0.06); }
        h1 { font-size: 3rem; font-weight: 700; background: linear-gradient(135deg, #bb86fc 0%, #03dac6 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; margin-bottom: 1rem; }
        .server-info { display: inline-flex; align-items: center; gap: 0.75rem; background: rgba(3, 218, 198, 0.1); padding: 0.75rem 1.5rem; border-radius: 50px; border: 1px solid rgba(3, 218, 198, 0.2); font-size: 0.95rem; margin-top: 1rem; }
        .controls-bar { display: flex; justify-content: flex-end; align-items: center; margin-bottom: 2rem; gap: 1rem; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem; }
        .stat-card { background: rgba(20, 20, 28, 0.6); backdrop-filter: blur(20px); padding: 1.5rem; border-radius: 16px; border: 1px solid rgba(255, 255, 255, 0.06); }
        .stat-label { font-size: 0.85rem; color: #9ca3af; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.5rem; }
        .stat-value { font-size: 2rem; font-weight: 700; }
        .section { margin-bottom: 2.5rem; }
        .section-header { display: flex; align-items: center; justify-content: space-between; gap: 0.75rem; margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 2px solid rgba(187, 134, 252, 0.2); }
        .section-header h2 { font-size: 1.5rem; font-weight: 600; color: #bb86fc; display: flex; align-items: center; gap: 0.5rem; }
        .channels-grid { display: grid; gap: 1rem; }
        .channel-card { background: rgba(20, 20, 28, 0.6); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.06); border-radius: 16px; padding: 1.5rem; transition: all 0.3s ease; display: grid; grid-template-columns: 1fr auto; gap: 1.5rem; align-items: center; }
        .channel-info { display: flex; flex-direction: column; gap: 0.25rem; }
        .channel-title { font-size: 1.15rem; font-weight: 600; }
        .channel-meta { display: flex; gap: 1rem; flex-wrap: wrap; margin-top: 0.5rem; }
        .meta-item { display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; color: #9ca3af; }
        .status-badge { padding: 0.5rem 1rem; border-radius: 8px; font-size: 0.75rem; font-weight: 700; text-transform: uppercase; }
        .status-streaming { background: rgba(34, 197, 94, 0.15); color: #22c55e; }
        .status-error, .status-failed { background: rgba(239, 68, 68, 0.15); color: #ef4444; }
        .status-initializing, .status-starting-ffmpeg, .status-authenticating, .status-parsing-dash { background: rgba(251, 146, 60, 0.15); color: #fb923c; }
        .status-idle, .status-stopped { background: rgba(100, 116, 139, 0.15); color: #94a3b8; }
        .btn { background: rgba(187, 134, 252, 0.1); border: 1.5px solid rgba(187, 134, 252, 0.3); color: #bb86fc; padding: 0.625rem 1.25rem; cursor: pointer; border-radius: 10px; font-size: 0.875rem; text-decoration: none; font-weight: 600; white-space: nowrap; }
        .btn:hover { background: #bb86fc; color: #0a0a0f; }
        .btn-stop, .btn-remove { border-color: rgba(239, 68, 68, 0.3); color: #ef4444; background: rgba(239, 68, 68, 0.1); }
        .btn-stop:hover, .btn-remove:hover { background: #ef4444; color: white; }
        .btn-start { border-color: rgba(34, 197, 94, 0.3); color: #22c55e; background: rgba(34, 197, 94, 0.1); }
        .btn-start:hover { background: #22c55e; color: white; }
        .actions-cell { display: flex; gap: 0.5rem; flex-wrap: wrap; justify-content: flex-end; }
        .empty-state { text-align: center; padding: 2rem; background: rgba(20, 20, 28, 0.4); border-radius: 16px; border: 2px dashed rgba(255, 255, 255, 0.1); }
        .form-card { background: rgba(20, 20, 28, 0.8); border: 1px solid rgba(187, 134, 252, 0.2); padding: 2rem; border-radius: 16px; }
        .form-grid { display: grid; gap: 1rem; }
        .form-grid input { width: 100%; background: #1c1c24; border: 1px solid #3a3a4a; color: #e8eaed; padding: 0.75rem; border-radius: 8px; font-size: 1rem; }
        .form-grid input::placeholder { color: #6b7280; }
        .form-grid .btn { justify-content: center; width: 100%; }
        #stream-id-edit-note { font-size: 0.8em; color: #9ca3af; }
    </style>
</head>
<body>
    <div class="container">
        <header><h1>Unified Streamer</h1><div class="server-info"><strong>{{ server_ip }}:{{ server_port }}</strong></div></header>
        <div class="stats-grid">
            <div class="stat-card"><div class="stat-label">Sling Channels</div><div class="stat-value" id="total-channels" style="color: #e8eaed;">0</div></div>
            <div class="stat-card"><div class="stat-label">Custom Streams</div><div class="stat-value" id="custom-count" style="color: #e8eaed;">0</div></div>
            <div class="stat-card"><div class="stat-label">Active Streams</div><div class="stat-value" id="active-count" style="color: #22c55e;">0</div></div>
            <div class="stat-card"><div class="stat-label">Total Clients</div><div class="stat-value" id="total-clients" style="color: #bb86fc;">0</div></div>
        </div>
        <div class="controls-bar"><button id="generate-m3u-btn" class="btn btn-start">üìã Generate M3U Playlist</button></div>
        <div id="active-streams-container" class="section" style="display: none;"><div class="section-header"><h2>‚ö° Active Streams</h2></div><div class="channels-grid" id="active-channels-grid"></div></div>
        <div id="custom-streams-section" class="section">
            <div class="section-header"><h2>üõ∞Ô∏è Custom DASH Streams</h2><button class="btn btn-start" id="toggle-form-btn">‚ûï Add Stream</button></div>
            <div id="add-stream-form-container" style="display:none; margin-bottom: 1.5rem;">
                <div class="form-card">
                    <form id="add-stream-form" class="form-grid">
                        <input type="text" id="stream-title" placeholder="Stream Title (e.g., My Live Channel)" required>
                        <input type="text" id="stream-id" placeholder="Stream ID (e.g., my-live-channel, optional)">
                        <span id="stream-id-edit-note" style="display: none;">The Stream ID cannot be changed during an edit.</span>
                        <input type="url" id="stream-mpd" placeholder="MPD URL (https://...)" required>
                        <input type="text" id="stream-key" placeholder="Decryption Key (e.g., a1b2c3d4...)" required>
                        <button type="submit" class="btn btn-start" id="form-submit-btn">Add Custom Stream</button>
                    </form>
                </div>
            </div>
            <div class="channels-grid" id="custom-channels-grid"><div class="empty-state">No custom streams configured.</div></div>
        </div>
        <div id="all-channels-container" class="section"><div class="section-header"><h2>üì∫ Available Sling Channels</h2></div><div class="channels-grid" id="all-channels-grid"><div class="empty-state">Loading channels...</div></div></div>
    </div>

<script>
    const SERVER_IP = "{{ server_ip }}";
    const SERVER_PORT = "{{ server_port }}";
    let currentEditId = null;
    let allCustomStreamsData = {};

    async function controlStream(action, streamId) { await fetch(`/api/stream/${action}/${streamId}`, { method: 'POST' }); fetchAndRender(); }
    async function removeCustomStream(streamId) { if (!confirm(`Are you sure you want to remove stream "${streamId}"?`)) return; await fetch(`/api/streams/${streamId}`, { method: 'DELETE' }); fetchAndRender(); }
    function copyToClipboard(text, element) { navigator.clipboard.writeText(text).then(() => { const o = element.innerHTML; element.innerHTML = '‚úì Copied!'; element.style.borderColor = '#22c55e'; setTimeout(() => { element.innerHTML = o; element.style.borderColor = ''; }, 2000); }); }
    function formatUptime(s) { if (!s || s <= 0) return "--:--:--"; const h = Math.floor(s / 3600).toString().padStart(2, '0'); const m = Math.floor((s % 3600) / 60).toString().padStart(2, '0'); const sec = Math.floor(s % 60).toString().padStart(2, '0'); return `${h}:${m}:${sec}`; }

    function showFormForEdit(streamId) {
        const streamData = allCustomStreamsData[streamId];
        if (!streamData) return;
        currentEditId = streamId;
        document.getElementById('stream-title').value = streamData.title;
        document.getElementById('stream-id').value = streamId;
        document.getElementById('stream-id').disabled = true;
        document.getElementById('stream-id-edit-note').style.display = 'block';
        document.getElementById('stream-mpd').value = streamData.mpd_url;
        document.getElementById('stream-key').value = streamData.key;
        document.getElementById('form-submit-btn').textContent = 'Update Stream';
        const formContainer = document.getElementById('add-stream-form-container');
        formContainer.style.display = 'block';
        formContainer.scrollIntoView({ behavior: 'smooth' });
    }

    function resetAndHideForm() {
        currentEditId = null;
        document.getElementById('add-stream-form').reset();
        document.getElementById('stream-id').disabled = false;
        document.getElementById('stream-id-edit-note').style.display = 'none';
        document.getElementById('form-submit-btn').textContent = 'Add Custom Stream';
        document.getElementById('add-stream-form-container').style.display = 'none';
    }

    function createChannelCard(stream, statusInfo) {
        const streamId = stream.id;
        const status = statusInfo ? statusInfo.status : 'IDLE';
        const isIdle = !statusInfo;
        const streamUrl = `http://${SERVER_IP}:${SERVER_PORT}/stream/${streamId}`;
        const statusClass = `status-${(status || 'idle').toLowerCase().replace(/_/g, '-')}`;
        const card = document.createElement('div');
        card.className = 'channel-card';
        let metaHtml = `<span class="status-badge ${statusClass}">${(status || 'idle').replace(/_/g, ' ')}</span>`;
        if (statusInfo) metaHtml += `<div class="meta-item"><span>‚è±Ô∏è</span><span>${formatUptime(statusInfo.uptime)}</span></div><div class="meta-item"><span>üë•</span><span>${statusInfo.clients || 0}</span></div>`;
        let actionsHtml = isIdle ? `<button class="btn btn-start" onclick="controlStream('start', '${streamId}')">‚ñ∂Ô∏è Start</button>` : `<button class="btn" onclick="controlStream('restart', '${streamId}')">üîÑ Restart</button><button class="btn btn-stop" onclick="controlStream('stop', '${streamId}')">‚èπÔ∏è Stop</button>`;
        actionsHtml += `<button class="btn" onclick="copyToClipboard('${streamUrl}', this)">üìã Copy URL</button>`;
        if (stream.type === 'dash') {
            if (isIdle) actionsHtml += `<button class="btn" onclick="showFormForEdit('${streamId}')">‚úèÔ∏è Edit</button>`;
            actionsHtml += `<button class="btn btn-remove" onclick="removeCustomStream('${streamId}')">üóëÔ∏è Remove</button>`;
        }
        card.innerHTML = `<div class="channel-info"><div class="channel-title">${stream.type === 'sling' ? 'üì∫' : 'üõ∞Ô∏è'} ${stream.title}</div><div class="channel-meta">${metaHtml}</div></div><div class="actions-cell">${actionsHtml}</div>`;
        return card;
    }

    async function fetchAndRender() {
        try {
            const [slingChannelsRes, customStreamsRes, statusRes] = await Promise.all([fetch('/api/channels'), fetch('/api/streams'), fetch('/api/status')]);
            const slingChannels = await slingChannelsRes.json();
            allCustomStreamsData = await customStreamsRes.json();
            const statuses = await statusRes.json();
            const allConfiguredStreams = [...slingChannels.map(c => ({...c, type: 'sling'})), ...Object.entries(allCustomStreamsData).map(([id, config]) => ({...config, id, type: 'dash'}))];
            const activeGrid = document.getElementById('active-channels-grid'), customGrid = document.getElementById('custom-channels-grid'), slingGrid = document.getElementById('all-channels-grid');
            activeGrid.innerHTML = ''; customGrid.innerHTML = ''; slingGrid.innerHTML = '';
            let activeStreams = [], totalClients = 0;
            allConfiguredStreams.forEach(stream => {
                const statusInfo = statuses[stream.id];
                const card = createChannelCard(stream, statusInfo);
                if (statusInfo) { activeStreams.push(card); totalClients += statusInfo.clients || 0; }
                else if (stream.type === 'dash') customGrid.appendChild(card);
                else if (stream.type === 'sling') slingGrid.appendChild(card);
            });
            const activeContainer = document.getElementById('active-streams-container');
            if (activeStreams.length > 0) { activeStreams.forEach(card => activeGrid.appendChild(card)); activeContainer.style.display = 'block'; } else { activeContainer.style.display = 'none'; }
            if (customGrid.innerHTML === '') customGrid.innerHTML = '<div class="empty-state">No idle custom streams.</div>';
            if (slingGrid.innerHTML === '') slingGrid.innerHTML = '<div class="empty-state">No idle Sling channels.</div>';
            document.getElementById('total-channels').textContent = slingChannels.length;
            document.getElementById('custom-count').textContent = Object.keys(allCustomStreamsData).length;
            document.getElementById('active-count').textContent = activeStreams.length;
            document.getElementById('total-clients').textContent = totalClients;
        } catch (error) { console.error("Failed to fetch data:", error); }
    }

    document.getElementById('toggle-form-btn').addEventListener('click', () => { 
        const formContainer = document.getElementById('add-stream-form-container');
        if (formContainer.style.display === 'none') {
            resetAndHideForm(); // Ensure form is clean before showing
            formContainer.style.display = 'block';
        } else {
            resetAndHideForm();
        }
    });
    
    document.getElementById('add-stream-form').addEventListener('submit', async (e) => {
        e.preventDefault();

        const payload = {
            title: document.getElementById('stream-title').value,
            mpd_url: document.getElementById('stream-mpd').value,
            key: document.getElementById('stream-key').value
        };

        let url, method;

        if (currentEditId) {
            method = 'PUT';
            url = `/api/streams/${currentEditId}`;
        } else {
            method = 'POST';
            url = '/api/streams';
            payload.id = document.getElementById('stream-id').value;
        }

        const response = await fetch(url, {
            method: method,
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(payload)
        });
        
        if (response.ok) {
            resetAndHideForm();
            fetchAndRender();
        } else {
            const result = await response.json();
            alert(`Error: ${result.message}`);
        }
    });
    
    document.getElementById('generate-m3u-btn').addEventListener('click', async () => {
        const [slingRes, customRes] = await Promise.all([fetch('/api/channels'), fetch('/api/streams')]);
        const allStreams = [...await slingRes.json(), ...Object.entries(await customRes.json()).map(([id, c]) => ({...c, id}))].sort((a,b) => a.title.localeCompare(b.title));
        let m3uContent = '#EXTM3U\n';
        allStreams.forEach(s => { m3uContent += `#EXTINF:-1,${s.title}\nhttp://${SERVER_IP}:${SERVER_PORT}/stream/${s.id}\n`; });
        const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([m3uContent], {type: 'application/vnd.apple.mpegurl'})); a.download = 'streams.m3u'; a.click();
    });

    fetchAndRender();
    setInterval(fetchAndRender, 5000);
</script>
</body>
</html>
